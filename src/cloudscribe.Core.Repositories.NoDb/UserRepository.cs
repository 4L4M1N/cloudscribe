// Copyright (c) Source Tree Solutions, LLC. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// Author:                  Joe Audette
// Created:                 2016-04-26
// Last Modified:           2016-04-26
// 

using cloudscribe.Core.Models;
using NoDb;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace cloudscribe.Core.Repositories.NoDb
{
    // just realized a flaw in my plan to try to implement cloudscribe repositories
    // with NoDb. The problem comes from using both integer ids and guids
    // guids are not a problem, they can be generated outside the db layer
    // but integer ids are a challenge since they would normally be generated by the db platform
    // using auto increment or sequences.
    // so to go forward I would need to implement something like a sequence to keep track of the assigned ids and
    // increment or jump to generate new ones
    // or change the models to only use guid ids

    public class UserRepository
    {
        public UserRepository(
            IProjectResolver projectResolver,
            IBasicCommands<SiteUser> userCommands,
            IBasicQueries<SiteUser> userQueries)
        {
            this.projectResolver = projectResolver;
            this.userCommands = userCommands;
            this.userQueries = userQueries;
        }

        private IProjectResolver projectResolver;
        private IBasicCommands<SiteUser> userCommands;
        private IBasicQueries<SiteUser> userQueries;

        protected string projectId;

        private async Task EnsureProjectId()
        {
            if(string.IsNullOrEmpty(projectId))
            {
                await projectResolver.ResolveProjectId().ConfigureAwait(false);
            }

        }

        #region User

        public async Task<bool> Save(
            ISiteUser user,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var result = false;
            if (user == null) { return result; }
            
            if (user.SiteGuid == Guid.Empty) { throw new ArgumentException("user must have a siteguid"); }

            await EnsureProjectId().ConfigureAwait(false);

            SiteUser siteUser = SiteUser.FromISiteUser(user);
            if (siteUser.UserGuid == Guid.Empty)
            {
                siteUser.UserGuid = Guid.NewGuid();
                
                result = await userCommands.CreateAsync(
                    projectId, 
                    siteUser.UserGuid.ToString(), 
                    siteUser, 
                    cancellationToken).ConfigureAwait(false);
            }
            else
            {
                result = await userCommands.UpdateAsync(
                    projectId, 
                    siteUser.UserGuid.ToString(), 
                    siteUser, 
                    cancellationToken).ConfigureAwait(false);

            }
            
            return result;

        }

        public async Task<bool> Delete(
            Guid siteGuid,
            Guid userGuid,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var result = false;

            await EnsureProjectId().ConfigureAwait(false);

            result = await userCommands.DeleteAsync(projectId, userGuid.ToString(), cancellationToken).ConfigureAwait(false);
            
            return result;

        }

        //public async Task<bool> DeleteUsersBySite(
        //    Guid siteGuid,
        //    CancellationToken cancellationToken = default(CancellationToken))
        //{
        //    bool result = await DeleteLoginsBySite(siteGuid);
        //    result = await DeleteClaimsBySite(siteGuid);
        //    result = await DeleteUserRolesBySite(siteGuid);

        //    var query = from x in dbContext.Users.Where(x => x.SiteGuid == siteGuid)
        //                select x;

        //    dbContext.Users.RemoveRange(query);
        //    int rowsAffected = await dbContext.SaveChangesAsync(cancellationToken)
        //        .ConfigureAwait(false);

        //    result = rowsAffected > 0;

        //    return result;
        //}

        public async Task<bool> FlagAsDeleted(
            Guid userGuid,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            var result = false;

            await EnsureProjectId().ConfigureAwait(false);

            var item
                = await userQueries.FetchAsync(
                    projectId,
                    userGuid.ToString(),
                    cancellationToken).ConfigureAwait(false);

            if (item == null) { return result; }

            item.IsDeleted = true;

            result = await userCommands.UpdateAsync(
                    projectId,
                    item.UserGuid.ToString(),
                    item,
                    cancellationToken).ConfigureAwait(false);

            return result;

        }

        #endregion


    }
}
