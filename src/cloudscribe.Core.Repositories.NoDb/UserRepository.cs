// Copyright (c) Source Tree Solutions, LLC. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// Author:                  Joe Audette
// Created:                 2016-04-26
// Last Modified:           2016-04-26
// 

using cloudscribe.Core.Models;
using NoDb;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace cloudscribe.Core.Repositories.NoDb
{
    // just realized a flaw in my plan to try to implement cloudscribe repositories
    // with NoDb. The problem comes from using both integer ids and guids
    // guids are not a problem, they can be generated outside the db layer
    // but integer ids are a challenge since they would normally be generated by the db platform
    // using auto increment or sequences.
    // so to go forward I would need to implement something like a sequence to keep track of the assigned ids and
    // increment or jump to generate new ones
    // or change the models to only use guid ids

    public class UserRepository
    {
        public UserRepository(
            IProjectResolver projectResolver,
            IBasicCommands<SiteUser> userCommands,
            IBasicQueries<SiteUser> userQueries)
        {
            this.projectResolver = projectResolver;
            this.userCommands = userCommands;
            this.userQueries = userQueries;
        }

        private IProjectResolver projectResolver;
        private IBasicCommands<SiteUser> userCommands;
        private IBasicQueries<SiteUser> userQueries;

        protected string projectId;

        private async Task EnsureProjectId()
        {
            if(string.IsNullOrEmpty(projectId))
            {
                await projectResolver.ResolveProjectId().ConfigureAwait(false);
            }

        }

        #region User

        public async Task<bool> Save(
            ISiteUser user,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            if (user == null) { return false; }
            if (user.SiteId == -1) { throw new ArgumentException("user must have a siteid"); }
            if (user.SiteGuid == Guid.Empty) { throw new ArgumentException("user must have a siteguid"); }

            await EnsureProjectId().ConfigureAwait(false);

            SiteUser siteUser = SiteUser.FromISiteUser(user);
            if (siteUser.UserId == -1)
            {
                siteUser.UserId = 0; //EF needs it to be zero in order to generate
                //dbContext.Users.Add(siteUser);
            }
            else
            {
                //bool tracking = dbContext.ChangeTracker.Entries<SiteUser>().Any(x => x.Entity.UserId == siteUser.UserId);
                //if (!tracking)
                //{
                //    //dbContext.Users.Update(siteUser);
                //}

            }

            //int rowsAffected =
            //    await dbContext.SaveChangesAsync(cancellationToken)
            //    .ConfigureAwait(false)
            //    ;

            //if (user.UserId == -1)
            //{
            //    user.UserId = siteUser.UserId;
            //    user.UserGuid = siteUser.UserGuid;
            //}

            //return rowsAffected > 0;

            return false;

        }

        #endregion


    }
}
