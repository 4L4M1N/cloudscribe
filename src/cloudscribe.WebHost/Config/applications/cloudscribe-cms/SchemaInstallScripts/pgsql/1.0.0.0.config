CREATE SEQUENCE mp_moduledefinitions_moduledefid_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;

CREATE SEQUENCE mp_moduledefinitionsettings_id_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;

CREATE SEQUENCE mp_modules_moduleid_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;

CREATE SEQUENCE mp_modulesettings_id_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;

CREATE SEQUENCE mp_pages_pageid_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;




CREATE TABLE mp_contentrating (
    rowguid character(36) NOT NULL,
    siteguid character(36) NOT NULL,
    contentguid character(36) NOT NULL,
    userguid character(36) NOT NULL,
    emailaddress character varying(100),
    rating integer NOT NULL,
    comments text,
    ipaddress character varying(50),
    createdutc timestamp without time zone NOT NULL,
    lastmodutc timestamp without time zone NOT NULL
);


CREATE TABLE mp_moduledefinitions (
    moduledefid integer DEFAULT nextval(('"mp_moduledefinitions_moduledefid_seq"'::text)::regclass) NOT NULL,
    featurename character varying(255) NOT NULL,
    controlsrc character varying(255) NOT NULL,
    sortorder integer DEFAULT 500 NOT NULL,
    isadmin boolean DEFAULT false NOT NULL,
    icon character varying(255),
    defaultcachetime integer DEFAULT 0 NOT NULL,
    guid character(36) NOT NULL,
    resourcefile character varying(255),
	iscacheable boolean,
  issearchable boolean,
  searchlistname character varying(255),
  supportspagereuse boolean,
  deleteprovider character varying(255),
  partialview character varying(50)
);



CREATE TABLE mp_moduledefinitionsettings (
    id integer DEFAULT nextval(('"mp_moduledefinitionsettings_id_seq"'::text)::regclass) NOT NULL,
    moduledefid integer NOT NULL,
    settingname character varying(50) NOT NULL,
    settingvalue character varying(255) NOT NULL,
    controltype character varying(50),
    regexvalidationexpression text,
    featureguid character(36) NOT NULL,
    resourcefile character varying(255),
    controlsrc character varying(255),
    helpkey character varying(255),
    sortorder integer DEFAULT 100 NOT NULL,
	groupname character varying(255)
);



CREATE TABLE mp_modules (
    moduleid integer DEFAULT nextval(('"mp_modules_moduleid_seq"'::text)::regclass) NOT NULL,
    moduledefid integer NOT NULL,
    moduletitle character varying(255),
    authorizededitroles text,
    cachetime integer NOT NULL,
    edituserid integer DEFAULT 0 NOT NULL,
    showtitle boolean DEFAULT true,
    siteid integer DEFAULT 0 NOT NULL,
    availableformypage boolean DEFAULT false NOT NULL,
    createdbyuserid integer,
    createddate timestamp without time zone,
    countofuseonmypage integer DEFAULT 0 NOT NULL,
    icon character varying(255),
    allowmultipleinstancesonmypage boolean DEFAULT true NOT NULL,
    guid character varying(36),
    featureguid character varying(36),
    siteguid character varying(36),
    edituserguid character varying(36),
    hidefromauth boolean DEFAULT false NOT NULL,
    hidefromunauth boolean DEFAULT false NOT NULL,
	viewroles text,
  drafteditroles text,
  includeinsearch boolean,
  isglobal boolean,
  headelement character varying(25),
  publishmode integer,
  draftapprovalroles text
);



CREATE TYPE mp_modules_selectbypage_type AS (
	moduleid integer,
	pageid integer,
	moduledefid integer,
	moduleorder integer,
	panename character varying(50),
	moduletitle character varying(255),
	authorizededitroles text,
	cachetime integer,
	showtitle boolean,
	controlsrc character varying(255)
);


CREATE TYPE mp_modules_selectbypageid_type AS (
	moduleid integer,
	pageid integer,
	moduledefid integer,
	moduleorder integer,
	panename character varying(50),
	moduletitle character varying(255),
	authorizededitroles text,
	cachetime integer,
	showtitle boolean,
	hidefromauth boolean,
	hidefromunauth boolean,
	controlsrc character varying(255),
	edituserid integer,
	availableformypage boolean,
	createdbyuserid integer,
	createddate timestamp without time zone,
	publishbegindate timestamp without time zone,
	publishenddate timestamp without time zone,
	guid character(36),
	featureguid character(36),
	siteguid character(36),
	edituserguid character(36)
);



CREATE TYPE mp_modules_selectone_type AS (
	moduleid integer,
	siteid integer,
	moduledefid integer,
	moduletitle character varying(255),
	authorizededitroles text,
	cachetime integer,
	showtitle boolean,
	hidefromauth boolean,
	hidefromunauth boolean,
	edituserid integer,
	availableformypage boolean,
	allowmultipleinstancesonmypage boolean,
	icon character varying(255),
	createdbyuserid integer,
	createddate timestamp without time zone,
	countofuseonmypage integer,
	guid character(36),
	featureguid character(36),
	siteguid character(36),
	edituserguid character(36)
);



CREATE TYPE mp_modules_selectonebypage_type AS (
	moduleid integer,
	siteid integer,
	pageid integer,
	moduledefid integer,
	moduleorder integer,
	panename character varying(50),
	moduletitle character varying(255),
	authorizededitroles text,
	cachetime integer,
	showtitle boolean,
	hidefromauth boolean,
	hidefromunauth boolean,
	edituserid integer,
	availableformypage boolean,
	allowmultipleinstancesonmypage boolean,
	countofuseonmypage integer,
	icon character varying(255),
	createdbyuserid integer,
	createddate timestamp without time zone,
	publishbegindate timestamp without time zone,
	publishenddate timestamp without time zone,
	controlsrc character varying(255),
	guid character(36),
	featureguid character(36),
	siteguid character(36),
	edituserguid character(36)
);



CREATE TYPE mp_modules_selectpage_type AS (
	moduleid integer,
	moduletitle character varying(255),
	featurename character varying(255),
	resourcefile character varying(255),
	controlsrc character varying(255),
	authorizededitroles text,
	createdby character varying(100),
	createddate timestamp without time zone
);



CREATE TABLE mp_modulesettings (
    id integer DEFAULT nextval(('"mp_modulesettings_id_seq"'::text)::regclass) NOT NULL,
    moduleid integer NOT NULL,
    settingname character varying(50) NOT NULL,
    settingvalue character varying(255) NOT NULL,
    controltype character varying(50),
    regexvalidationexpression text,
    moduleguid character varying(36),
    settingguid character varying(36),
    controlsrc character varying(255),
    helpkey character varying(255),
    sortorder integer DEFAULT 100 NOT NULL
);




CREATE TYPE mp_modulesettings_select_type AS (
	id integer,
	moduleid integer,
	settingname character varying(50),
	settingvalue character varying(255),
	controltype character varying(50),
	controlsrc character varying(255),
	helpkey character varying(255),
	sortorder integer,
	regexvalidationexpression text,
	featureguid character(36),
	resourcefile character varying(255)
);


CREATE TABLE mp_pagemodules (
    pageid integer NOT NULL,
    moduleid integer NOT NULL,
    panename character varying(50),
    moduleorder integer NOT NULL,
    publishbegindate timestamp without time zone NOT NULL,
    publishenddate timestamp without time zone,
    moduleguid character varying(36),
    pageguid character varying(36)
);


CREATE TABLE mp_pages (
    pageid integer DEFAULT nextval(('"mp_pages_pageid_seq"'::text)::regclass) NOT NULL,
    parentid integer DEFAULT -1,
    pageorder integer NOT NULL,
    siteid integer NOT NULL,
    pagename character varying(50) NOT NULL,
    pagetitle character varying(255),
    authorizedroles text,
    editroles text,
    createchildpageroles text,
    requiressl boolean DEFAULT false NOT NULL,
    allowbrowsercache boolean DEFAULT true NOT NULL,
    showbreadcrumbs boolean DEFAULT false NOT NULL,
    pagekeywords character varying(255),
    pagedescription character varying(255),
    pageencoding character varying(255),
    additionalmetatags character varying(255),
    menuimage character varying(50),
    useurl boolean DEFAULT false NOT NULL,
    url character varying(255),
    openinnewwindow boolean DEFAULT false NOT NULL,
    showchildbreadcrumbs boolean DEFAULT false NOT NULL,
    showchildpagemenu boolean DEFAULT false NOT NULL,
    hidemainmenu boolean DEFAULT false NOT NULL,
    skin character varying(100),
    includeinmenu boolean DEFAULT true NOT NULL,
    changefrequency character varying(20),
    sitemappriority character varying(10),
    lastmodifiedutc timestamp without time zone,
    pageguid character(36),
    parentguid character(36),
    hideafterlogin boolean DEFAULT false NOT NULL,
    siteguid character varying(36),
    compiledmeta text,
    compiledmetautc timestamp without time zone,
	includeinsitemap boolean,
  isclickable boolean,
  showhomecrumb boolean,
  drafteditroles text,
  ispending boolean,
  canonicaloverride character varying(255),
  includeinsearchmap boolean,
  enablecomments boolean,
  createchilddraftroles text,
  includeinchildsitemap boolean,
  pubteamid character(36),
  bodycssclass character varying(50),
  menucssclass character varying(50),
  expandonsitemap boolean,
  publishmode integer,
  pcreatedutc timestamp without time zone,
  pcreatedby character varying(36),
  pcreatedfromip character varying(36),
  plastmodutc timestamp without time zone,
  plastmodby character varying(36),
  plastmodfromip character varying(36),
  menudesc text,
  draftapprovalroles text,
  linkrel character varying(20),
  pageheading character varying(255),
  showpageheading boolean NOT NULL DEFAULT true,
  pubdateutc timestamp without time zone
);




CREATE TYPE mp_pages_getauthroles_type AS (
	accessroles character varying(255),
	editroles character varying(255)
);






CREATE TYPE mp_pages_type AS (
	pageid integer,
	parentid integer,
	pageorder integer,
	siteid integer,
	pagename character varying(50),
	pagetitle character varying(255),
	requiressl boolean,
	allowbrowsercache boolean,
	showbreadcrumbs boolean,
	pagekeywords character varying(255),
	pagedescription character varying(255),
	pageencoding character varying(255),
	additionalmetatags character varying(255),
	menuimage character varying(50),
	useurl boolean,
	url character varying(255),
	openinnewwindow boolean,
	showchildpagemenu boolean,
	authorizedroles text,
	editroles text,
	createchildpageroles text,
	showchildbreadcrumbs boolean,
	hidemainmenu boolean,
	skin character varying(100),
	includeinmenu boolean,
	changefrequency character varying(20),
	sitemappriority character varying(10),
	lastmodifiedutc timestamp without time zone,
	pageguid character(36),
	parentguid character(36),
	hideafterlogin boolean
);

CREATE TABLE mp_sitemoduledefinitions (
    siteid integer NOT NULL,
    moduledefid integer NOT NULL,
    authorizedroles text,
    siteguid character varying(36),
    featureguid character varying(36)
);




CREATE TYPE mp_sitesettings_getpagelist_type AS (
	pageid integer,
	parentid integer,
	pageorder integer,
	siteid integer,
	pagename character varying(50),
	menuimage character varying(50),
	requiressl boolean,
	showbreadcrumbs boolean,
	pagekeywords character varying(255),
	pagedescription character varying(255),
	pageencoding character varying(255),
	additionalmetatags character varying(255),
	useurl boolean,
	url character varying(255),
	openinnewwindow boolean,
	showchildpagemenu boolean,
	authorizedroles text,
	editroles text,
	createchildpageroles text,
	showchildbreadcrumbs boolean,
	hidemainmenu boolean,
	skin character varying(100),
	includeinmenu boolean
);


CREATE TYPE mp_pages_selecttreeformodule_type AS (
	pageid integer,
	parentid integer,
	pagename character varying(100),
	pageorder integer,
	nestlevel integer,
	authorizedroles text,
	editroles text,
	createchildpageroles text,
	ispublished integer,
	panename character varying(50),
	moduleorder integer,
	publishbegindate timestamp without time zone,
	publishenddate timestamp without time zone
);




CREATE FUNCTION mp_moduledefinitions_delete(integer) RETURNS integer
    AS $_$
declare
	_moduledefid alias for $1;
	_rowcount int4;
begin

	delete from 
    mp_moduledefinitions
where
    moduledefid = _moduledefid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;


CREATE FUNCTION mp_moduledefinitions_deletesettingbyid(integer) RETURNS integer
    AS $_$
declare
	_id alias for $1;
	_rowcount int4;
begin

	delete from 
    mp_moduledefinitionsettings
where
    id = _id; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;



CREATE FUNCTION mp_moduledefinitions_selectone(integer) RETURNS SETOF mp_moduledefinitions
    AS $_$
select	*
from
    mp_moduledefinitions
where
    moduledefid = $1; $_$
    LANGUAGE sql SECURITY DEFINER;




CREATE FUNCTION mp_moduledefinitions_selectonebyguid(character) RETURNS SETOF mp_moduledefinitions
    AS $_$
select	*
from
    mp_moduledefinitions
where
    guid = $1; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_moduledefinitions_selectusermodules(integer) RETURNS SETOF mp_moduledefinitions
    AS $_$
select   		md.*
from			mp_moduledefinitions md
join			mp_sitemoduledefinitions smd
on			smd.moduledefid = md.moduledefid
    
where   		smd.siteid = $1
			and md.isadmin = false
order by 		md.sortorder, md.featurename; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_moduledefinitionsettings_select(integer) RETURNS SETOF mp_moduledefinitionsettings
    AS $_$
select
    *
from
    mp_moduledefinitionsettings
where
    moduledefid = $1
    order by sortorder
    ; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_moduledefinitionsettings_selectone(character, character varying) RETURNS SETOF mp_moduledefinitionsettings
    AS $_$
select
    *
from
    mp_moduledefinitionsettings
where
    featureguid = $1 and settingname = $2; $_$
    LANGUAGE sql SECURITY DEFINER;




CREATE FUNCTION mp_modules_countnonadmin(integer) RETURNS integer
    AS $_$
select	cast(count(m.*) as int4)
from		mp_modules m
join		mp_moduledefinitions md
on		m.moduledefid = md.moduledefid
where	siteid = $1 AND md.isadmin = false; $_$
    LANGUAGE sql SECURITY DEFINER;




CREATE FUNCTION mp_modules_delete(integer) RETURNS integer
    AS $_$
declare
	_moduleid alias for $1;
	_rowcount int4;
begin

delete from  mp_pagemodules
where moduleid = _moduleid;

delete from  mp_modules
where moduleid = _moduleid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;



CREATE FUNCTION mp_modules_deleteinstance(integer, integer) RETURNS integer
    AS $_$
declare
	_moduleid alias for $1;
	_pageid alias for $2;
	_rowcount int4;
begin

	delete from  mp_pagemodules
where moduleid = _moduleid and pageid = _pageid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;


CREATE FUNCTION mp_modules_updatemoduleorder(integer, integer, integer, character varying) RETURNS integer
    AS $_$
declare
	_pageid alias for $1;
	_moduleid alias for $2;
	_moduleorder alias for $3;
	_panename alias for $4;
	_rowcount int4;
begin

update
    mp_pagemodules
set
    moduleorder = _moduleorder,
    panename    = _panename
where
    moduleid = _moduleid and pageid = _pageid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;



CREATE FUNCTION mp_modules_updatepage(integer, integer, integer) RETURNS integer
    AS $_$
update 	mp_pagemodules 
set
				
	pageid = $2,
	pageguid = (SELECT pageguid FROM mp_pages WHERE pageid = $2 LIMIT 1)
				
where moduleid = $3 and pageid = $1;
--GET DIAGNOSTICS _rowcount = ROW_COUNT;
--return _rowcount;
select 1; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_modulesettings_delete(integer) RETURNS integer
    AS $_$
declare
	_moduleid alias for $1;
	_rowcount int4;
begin

	delete from  mp_modulesettings
where	moduleid = _moduleid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;





CREATE FUNCTION mp_pagemodule_exists(integer, integer) RETURNS integer
    AS $_$
select	cast(count(*) as int4)
from		mp_pagemodules
where	moduleid = $1 AND pageid = $2; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_pagemodule_selectbymodule(integer) RETURNS SETOF mp_pagemodules
    AS $_$
select	mp.*
from		mp_pagemodules mp
where	mp.moduleid = $1
order by pageid; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_pagemodule_selectbypage(integer) RETURNS SETOF mp_pagemodules
    AS $_$
select	mp.*
from		mp_pagemodules mp
where	mp.pageid = $1
order by pageid; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_pagemodules_insert(integer, integer, integer, character varying, timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
insert into mp_pagemodules(
pageid, 
moduleid, 
pageguid, 
moduleguid, 
moduleorder, 
panename, 
publishbegindate, 
publishenddate
)
values (
$1, 
$2, 
(SELECT pageguid FROM mp_pages WHERE pageid = $1 LIMIT 1),
(SELECT guid FROM mp_modules WHERE moduleid = $2 LIMIT 1),
$3, 
$4, 
$5, 
$6);
--GET DIAGNOSTICS rowcount = ROW_COUNT;
select 1;
 $_$
    LANGUAGE sql SECURITY DEFINER;





CREATE FUNCTION mp_pages_getnextpageorder(integer, integer) RETURNS integer
    AS $_$
select	coalesce(max(pageorder), -1) + 2
from		mp_pages
where siteid = $1 and parentid = $2; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_pages_getpagelist(integer) RETURNS SETOF mp_pages
    AS $_$
select  
    		*
    
from    
    		mp_pages
    
where   
    		siteid = $1 
order by	parentid, pageorder, pagename; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_pages_selectlist(integer) RETURNS SETOF mp_pages
    AS $_$
select  	*
    				
    
from    
    				mp_pages
    
where   
    				siteid = $1
order by			parentid,  pagename; $_$
    LANGUAGE sql SECURITY DEFINER;



CREATE FUNCTION mp_pages_updatepageorder(integer, integer) RETURNS integer
    AS $_$
declare
	_pageid alias for $1;
	_pageorder alias for $2;
	_rowcount int4;
begin

update
    mp_pages
set
    pageorder = _pageorder
where
    pageid = _pageid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;



CREATE FUNCTION mp_pages_updatetimestamp(integer, timestamp without time zone) RETURNS integer
    AS $_$
declare
	_pageid alias for $1;
	_lastmodifiedutc alias for $2;
	_rowcount int4;
begin

update
    mp_pages
set
    lastmodifiedutc = _lastmodifiedutc
where
    pageid = _pageid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;



CREATE FUNCTION mp_sitemoduledefinitions_delete(integer, integer) RETURNS integer
    AS $_$
declare
	_siteid alias for $1;
	_moduledefid alias for $2;
	_rowcount int4;
begin

	delete from  mp_sitemoduledefinitions
where	siteid = _siteid 
		and moduledefid = _moduledefid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;



CREATE FUNCTION mp_sitemoduledefinitions_deletev2(character, character) RETURNS integer
    AS $_$
declare
	_siteguid alias for $1;
	_featureguid alias for $2;
	_rowcount int4;
begin

	delete from  mp_sitemoduledefinitions
where	siteguid = _siteguid 
		and featureguid = _featureguid; 
GET DIAGNOSTICS _rowcount = ROW_COUNT;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;




CREATE FUNCTION mp_sitemoduledefinitions_insert(integer, integer) RETURNS integer
    AS $_$
declare
	_siteid alias for $1;
	_moduledefid alias for $2;
	t_found int;
	_rowcount int4;

begin

_rowcount := 0;
select into t_found 1 from mp_sitemoduledefinitions where siteid = _siteid and moduledefid = _moduledefid limit 1;
if not found then
	insert into mp_sitemoduledefinitions (
	siteid, 
	moduledefid,
	siteguid, 
	featureguid
	)
	
	values	(
	_siteid, 
	_moduledefid,
	(SELECT siteguid FROM mp_sites WHERE siteid = _siteid LIMIT 1),
	(SELECT guid FROM mp_moduledefinitions WHERE moduledefid = _moduledefid LIMIT 1)
	);   
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
end if;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;



CREATE FUNCTION mp_sitemoduledefinitions_insertv2(character, character) RETURNS integer
    AS $_$
declare
	_siteguid alias for $1;
	_featureguid alias for $2;
	t_found int;
	_rowcount int4;

begin

_rowcount := 0;
select into t_found 1 from mp_sitemoduledefinitions where siteguid = _siteguid and featureguid = _featureguid limit 1;
if not found then
	insert into mp_sitemoduledefinitions (
	siteid, 
	moduledefid,
	siteguid, 
	featureguid
	)
	
	values	(
	(SELECT siteid FROM mp_sites WHERE siteguid = _siteguid LIMIT 1),
	(SELECT moduledefid FROM mp_moduledefinitions WHERE guid = _featureguid LIMIT 1),
	__siteguid,
	_featureguid
	);   
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
end if;
return _rowcount;
end$_$
    LANGUAGE plpgsql SECURITY DEFINER;




ALTER TABLE ONLY mp_sitemoduledefinitions
    ADD CONSTRAINT mp_sitemoduledefinitions_pkey PRIMARY KEY (siteid, moduledefid);


ALTER TABLE ONLY mp_contentrating
    ADD CONSTRAINT pk_contentrating PRIMARY KEY (rowguid);


ALTER TABLE ONLY mp_moduledefinitions
    ADD CONSTRAINT pk_moduledefinitions PRIMARY KEY (moduledefid);

ALTER TABLE ONLY mp_moduledefinitionsettings
    ADD CONSTRAINT pk_moduledefinitionsettings PRIMARY KEY (id);


ALTER TABLE ONLY mp_modules
    ADD CONSTRAINT pk_modules PRIMARY KEY (moduleid);


ALTER TABLE ONLY mp_modulesettings
    ADD CONSTRAINT pk_modulesettings PRIMARY KEY (id);


ALTER TABLE ONLY mp_pagemodules
    ADD CONSTRAINT pk_pagemodules PRIMARY KEY (pageid, moduleid);


ALTER TABLE ONLY mp_pages
    ADD CONSTRAINT pk_pages PRIMARY KEY (pageid);


	



CREATE INDEX idxcontentratingg ON mp_contentrating USING btree (contentguid);
CREATE INDEX idxcontentratingi ON mp_contentrating USING btree (ipaddress);
CREATE INDEX idxcontentratings ON mp_contentrating USING btree (siteguid);
CREATE INDEX idxcontentratingu ON mp_contentrating USING btree (userguid);
CREATE INDEX ifk_modulesettings_moduleid ON mp_modulesettings USING btree (moduleid);
CREATE INDEX ifk_pagemodules_moduleid ON mp_pagemodules USING btree (moduleid);
CREATE INDEX ifk_pagemodules_pageid ON mp_pagemodules USING btree (pageid);
CREATE INDEX ifk_pages_siteid ON mp_pages USING btree (siteid);

CREATE INDEX ifk_sitemoduledefinitions_siteid ON mp_sitemoduledefinitions USING btree (siteid);


CREATE UNIQUE INDEX mp_contentrating_pkey ON mp_contentrating USING btree (rowguid);

CREATE INDEX mp_modulesettings_ix_modul_0 ON mp_modulesettings USING btree (moduleid, settingname);


ALTER TABLE ONLY mp_modules
    ADD CONSTRAINT fk_modules_moduledefinitions_fk FOREIGN KEY (moduledefid) REFERENCES mp_moduledefinitions(moduledefid);


ALTER TABLE ONLY mp_modulesettings
    ADD CONSTRAINT fk_modulesettings_modules FOREIGN KEY (moduleid) REFERENCES mp_modules(moduleid);

ALTER TABLE ONLY mp_pagemodules
    ADD CONSTRAINT fk_pagemodules_modules FOREIGN KEY (moduleid) REFERENCES mp_modules(moduleid);

ALTER TABLE ONLY mp_pagemodules
    ADD CONSTRAINT fk_pagemodules_pages FOREIGN KEY (pageid) REFERENCES mp_pages(pageid);


ALTER TABLE ONLY mp_pages
    ADD CONSTRAINT fk_pages_sites FOREIGN KEY (siteid) REFERENCES mp_sites(siteid);

ALTER TABLE ONLY mp_sitemoduledefinitions
    ADD CONSTRAINT fk_sitemoduledefinitions_sites FOREIGN KEY (siteid) REFERENCES mp_sites(siteid);



CREATE TABLE mp_category
(
  guid character(36) NOT NULL,
  parentguid character(36) NOT NULL,
  siteguid character(36) NOT NULL,
  featureguid character(36) NOT NULL,
  moduleguid character(36) NOT NULL,
  category character varying(255) NOT NULL,
  description character varying,
  itemcount integer NOT NULL,
  createdutc timestamp without time zone NOT NULL,
  createdby character(36) NOT NULL,
  modifiedutc timestamp without time zone NOT NULL,
  modifiedby character(36) NOT NULL,
  CONSTRAINT pk_category PRIMARY KEY (guid)
);



CREATE INDEX ixcategoryfeatureguid
  ON mp_category
  USING btree
  (featureguid COLLATE pg_catalog."default");


CREATE INDEX ixcategorymoduleguid
  ON mp_category
  USING btree
  (moduleguid COLLATE pg_catalog."default");


CREATE INDEX ixcategorysiteguid
  ON mp_category
  USING btree
  (siteguid COLLATE pg_catalog."default");


CREATE UNIQUE INDEX mp_category_pkey
  ON mp_category
  USING btree
  (guid COLLATE pg_catalog."default");
  
  CREATE TABLE mp_categoryitem
(
  guid character(36) NOT NULL,
  siteguid character(36) NOT NULL,
  featureguid character(36) NOT NULL,
  moduleguid character(36) NOT NULL,
  itemguid character(36) NOT NULL,
  categoryguid character(36) NOT NULL,
  extraguid character(36) NOT NULL,
  CONSTRAINT pk_categoryitem PRIMARY KEY (guid)

);


CREATE INDEX ixcatitemcatguid
  ON mp_categoryitem
  USING btree
  (categoryguid COLLATE pg_catalog."default");

CREATE INDEX ixcatitemextraguid
  ON mp_categoryitem
  USING btree
  (extraguid COLLATE pg_catalog."default");

CREATE INDEX ixcatitemfeatureguid
  ON mp_categoryitem
  USING btree
  (featureguid COLLATE pg_catalog."default");

CREATE INDEX ixcatitemitemguid
  ON mp_categoryitem
  USING btree
  (itemguid COLLATE pg_catalog."default");


CREATE INDEX ixcatitemmoduleguid
  ON mp_categoryitem
  USING btree
  (moduleguid COLLATE pg_catalog."default");


CREATE INDEX ixcatitemsiteguid
  ON mp_categoryitem
  USING btree
  (siteguid COLLATE pg_catalog."default");


CREATE UNIQUE INDEX mp_categoryitem_pkey
  ON mp_categoryitem
  USING btree
  (guid COLLATE pg_catalog."default");
  
  CREATE TABLE mp_comments
(
  guid character(36) NOT NULL,
  parentguid character(36) NOT NULL,
  siteguid character(36) NOT NULL,
  featureguid character(36) NOT NULL,
  moduleguid character(36) NOT NULL,
  contentguid character(36) NOT NULL,
  userguid character(36) NOT NULL,
  title character varying(255),
  usercomment character varying NOT NULL,
  username character varying(50) NOT NULL,
  useremail character varying(100) NOT NULL,
  userurl character varying(255),
  userip character varying(50) NOT NULL,
  createdutc timestamp without time zone NOT NULL,
  lastmodutc timestamp without time zone NOT NULL,
  moderationstatus smallint NOT NULL,
  moderatedby character(36) NOT NULL,
  moderationreason character varying(255),
  CONSTRAINT pk_comments PRIMARY KEY (guid)

);


CREATE INDEX ixcommentcomment
  ON mp_comments
  USING btree
  (contentguid COLLATE pg_catalog."default");

CREATE INDEX ixcommentfeatureguid
  ON mp_comments
  USING btree
  (featureguid COLLATE pg_catalog."default");

CREATE INDEX ixcommentmoduleguid
  ON mp_comments
  USING btree
  (moduleguid COLLATE pg_catalog."default");

CREATE INDEX ixcommentsiteguid
  ON mp_comments
  USING btree
  (siteguid COLLATE pg_catalog."default");

CREATE UNIQUE INDEX mp_comments_pkey
  ON mp_comments
  USING btree
  (guid COLLATE pg_catalog."default");
  
  
CREATE TABLE mp_contentmeta
(
  guid character(36) NOT NULL,
  siteguid character(36) NOT NULL,
  moduleguid character(36) NOT NULL,
  contentguid character(36) NOT NULL,
  name character varying(255) NOT NULL,
  scheme character varying(255) NOT NULL,
  langcode character varying(10),
  dir character varying(3),
  metacontent text,
  sortrank integer NOT NULL,
  createdutc timestamp without time zone NOT NULL,
  createdby character(36) NOT NULL,
  lastmodutc timestamp without time zone NOT NULL,
  lastmodby character(36) NOT NULL,
  CONSTRAINT pk_contentmeta PRIMARY KEY (guid)

);



CREATE INDEX idxcmetacguid
  ON mp_contentmeta
  USING btree
  (contentguid COLLATE pg_catalog."default");

CREATE INDEX idxcmetamodguid
  ON mp_contentmeta
  USING btree
  (moduleguid COLLATE pg_catalog."default");

CREATE INDEX idxcmetasiteguid
  ON mp_contentmeta
  USING btree
  (siteguid COLLATE pg_catalog."default");

CREATE UNIQUE INDEX mp_contentmeta_pkey
  ON mp_contentmeta
  USING btree
  (guid COLLATE pg_catalog."default");

CREATE TABLE mp_contentmetalink
(
  guid character(36) NOT NULL,
  siteguid character(36) NOT NULL,
  moduleguid character(36) NOT NULL,
  contentguid character(36) NOT NULL,
  rel character varying(255) NOT NULL,
  href character varying(255) NOT NULL,
  hreflang character varying(10),
  rev character varying(50),
  type character varying(50),
  media character varying(50),
  sortrank integer NOT NULL,
  createdutc timestamp without time zone NOT NULL,
  createdby character(36) NOT NULL,
  lastmodutc timestamp without time zone NOT NULL,
  lastmodby character(36) NOT NULL,
  CONSTRAINT pk_contentmetalink PRIMARY KEY (guid)

);


CREATE INDEX idxcmetalcguid
  ON mp_contentmetalink
  USING btree
  (contentguid COLLATE pg_catalog."default");

CREATE INDEX idxcmetalmodguid
  ON mp_contentmetalink
  USING btree
  (moduleguid COLLATE pg_catalog."default");

CREATE INDEX idxcmetalsiteguid
  ON mp_contentmetalink
  USING btree
  (siteguid COLLATE pg_catalog."default");

CREATE UNIQUE INDEX mp_contentmetalink_pkey
  ON mp_contentmetalink
  USING btree
  (guid COLLATE pg_catalog."default");
  

CREATE TABLE mp_tag
(
  guid character(36) NOT NULL,
  siteguid character(36) NOT NULL,
  featureguid character(36) NOT NULL,
  moduleguid character(36) NOT NULL,
  tag character varying(255) NOT NULL,
  createdutc timestamp without time zone NOT NULL,
  createdby character(36) NOT NULL,
  modifiedutc timestamp without time zone NOT NULL,
  modifiedby character(36) NOT NULL,
  itemcount integer NOT NULL,
  vocabularyguid character(36),
  CONSTRAINT pk_tag PRIMARY KEY (guid)

);



CREATE INDEX ixtagfeatureguid
  ON mp_tag
  USING btree
  (featureguid COLLATE pg_catalog."default");

CREATE INDEX ixtagmoduleguid
  ON mp_tag
  USING btree
  (moduleguid COLLATE pg_catalog."default");

CREATE INDEX ixtagsiteguid
  ON mp_tag
  USING btree
  (siteguid COLLATE pg_catalog."default");

CREATE UNIQUE INDEX mp_tag_pkey
  ON mp_tag
  USING btree
  (guid COLLATE pg_catalog."default");
  
CREATE TABLE mp_tagitem
(
  guid character(36) NOT NULL,
  siteguid character(36) NOT NULL,
  featureguid character(36) NOT NULL,
  moduleguid character(36) NOT NULL,
  itemguid character(36) NOT NULL,
  tagguid character(36) NOT NULL,
  extraguid character(36) NOT NULL,
  taggedby character(36) NOT NULL,
  CONSTRAINT pk_tagitem PRIMARY KEY (guid)

);


CREATE INDEX ixtagitemextraguid
  ON mp_tagitem
  USING btree
  (extraguid COLLATE pg_catalog."default");

CREATE INDEX ixtagitemfeatureguid
  ON mp_tagitem
  USING btree
  (featureguid COLLATE pg_catalog."default");

CREATE INDEX ixtagitemitemguid
  ON mp_tagitem
  USING btree
  (itemguid COLLATE pg_catalog."default");

CREATE INDEX ixtagitemmoduleguid
  ON mp_tagitem
  USING btree
  (moduleguid COLLATE pg_catalog."default");

CREATE INDEX ixtagitemsiteguid
  ON mp_tagitem
  USING btree
  (siteguid COLLATE pg_catalog."default");

CREATE INDEX ixtagitemtagguid
  ON mp_tagitem
  USING btree
  (tagguid COLLATE pg_catalog."default");

CREATE UNIQUE INDEX mp_tagitem_pkey
  ON mp_tagitem
  USING btree
  (guid COLLATE pg_catalog."default");
  